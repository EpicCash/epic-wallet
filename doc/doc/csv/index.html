<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate provides a streaming CSV (comma separated values) writer and reader that works with the `serialize` crate to do type based encoding and decoding. There are two primary goals of this project:"><meta name="keywords" content="rust, rustlang, rust-lang, csv"><title>csv - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../csv/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate csv</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.15.0</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all csv's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></div><div id="sidebar-vars" data-name="csv" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">csv</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/csv/lib.rs.html#1-325" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate provides a streaming CSV (comma separated values) writer and
reader that works with the <code>serialize</code> crate to do type based encoding
and decoding. There are two primary goals of this project:</p>
<ol>
<li>The default mode of parsing should <em>just work</em>. This means the parser
will bias toward providing <em>a</em> parse over a <em>correct</em> parse (with
respect to RFC 4180).</li>
<li>Convenient to use by default, but when performance is needed, the
API will provide an escape hatch.</li>
</ol>
<h2 id="simple-example" class="section-header"><a href="#simple-example">Simple example</a></h2>
<p>This shows how you can decode records into Rust types. This saves a ton
of boiler plate, e.g., converting strings to numeric types.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;
sticker,mortals,7
bribed,personae,7
wobbling,poncing,4
interposed,emmett,9
chocolate,refile,7&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">csv::Reader::from_string</span>(<span class="ident">data</span>).<span class="ident">has_headers</span>(<span class="bool-val">false</span>);
<span class="kw">for</span> <span class="ident">row</span> <span class="kw">in</span> <span class="ident">rdr</span>.<span class="ident">decode</span>() {
    <span class="kw">let</span> (<span class="ident">n1</span>, <span class="ident">n2</span>, <span class="ident">dist</span>): (<span class="ident">String</span>, <span class="ident">String</span>, <span class="ident">u32</span>) <span class="op">=</span> <span class="ident">row</span>.<span class="ident">unwrap</span>();
    <span class="macro">println!</span>(<span class="string">&quot;{}, {}: {}&quot;</span>, <span class="ident">n1</span>, <span class="ident">n2</span>, <span class="ident">dist</span>);
}</code></pre></div>
<p>If you just want a <code>Vec</code> of all the records, then you can use the
<code>collect</code> method defined on iterators:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;
sticker,mortals,7
bribed,personae,7
wobbling,poncing,4
interposed,emmett,9
chocolate,refile,7&quot;</span>;

<span class="kw">type</span> <span class="ident">Row</span> <span class="op">=</span> (<span class="ident">String</span>, <span class="ident">String</span>, <span class="ident">u32</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">csv::Reader::from_string</span>(<span class="ident">data</span>).<span class="ident">has_headers</span>(<span class="bool-val">false</span>);
<span class="kw">let</span> <span class="ident">rows</span> <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">decode</span>().<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">csv::Result</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Row</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">rows</span>.<span class="ident">len</span>(), <span class="number">5</span>);</code></pre></div>
<p>Please see the <code>Reader</code> type for more documentation and examples.</p>
<h2 id="iteratoring-over-records" class="section-header"><a href="#iteratoring-over-records">Iteratoring over records</a></h2>
<p>This crate exposes <strong>4</strong> distinct ways of iterating over CSV records. In
the majority of use cases, you should use the <code>decode</code> method as shown
above because it is the most convenient. But other types of iterators are
exposed for when you need them.</p>
<p>The iterators listed below are presented in order of performance. The first
(type based decoding) is the slowest and the last (zero allocation) is the
fastest. There is clear evidence of this claim in the benchmarks. (Just
run <code>cargo bench</code>.)</p>
<h3 id="decoded-records" class="section-header"><a href="#decoded-records">Decoded records</a></h3>
<p>As shown above. This uses type based decoding on each record.</p>
<h3 id="string-records" class="section-header"><a href="#string-records">String records</a></h3>
<p>Yields each record as a <code>Vec&lt;String&gt;</code>. Namely, this assumes that all CSV
data is UTF-8 encoded. This is the standard CSV interface that you’ve
probably come to expect from using other CSV parsers.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;
sticker,mortals,7
bribed,personae,7
wobbling,poncing,4
interposed,emmett,9
chocolate,refile,7&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">csv::Reader::from_string</span>(<span class="ident">data</span>).<span class="ident">has_headers</span>(<span class="bool-val">false</span>);
<span class="kw">for</span> <span class="ident">row</span> <span class="kw">in</span> <span class="ident">rdr</span>.<span class="ident">records</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">r</span><span class="op">|</span> <span class="ident">r</span>.<span class="ident">unwrap</span>()) {
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">row</span>);
}</code></pre></div>
<h3 id="byte-string-records" class="section-header"><a href="#byte-string-records">Byte string records</a></h3>
<p>Yields each record as a <code>Vec&lt;ByteString&gt;</code>. Namely, this allows reading CSV
data that is not UTF-8 encoded (or improperly encoded!).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">b&quot;
sti\xffcker,mortals,7
chocolate,refile,7&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">csv::Reader::from_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>[..]).<span class="ident">has_headers</span>(<span class="bool-val">false</span>);
<span class="kw">for</span> <span class="ident">row</span> <span class="kw">in</span> <span class="ident">rdr</span>.<span class="ident">byte_records</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">r</span><span class="op">|</span> <span class="ident">r</span>.<span class="ident">unwrap</span>()) {
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">row</span>);
}</code></pre></div>
<h3 id="byte-slice-records" class="section-header"><a href="#byte-slice-records">Byte slice records</a></h3>
<p>This iterator is defined on the <code>Reader</code> type itself and yields <em>fields</em>
instead of records (unlike the other iterators). Each field is a <code>&amp;[u8]</code>.
No allocation is performed during parsing (unlike the other iterators,
which at least allocate a <code>Vec&lt;u8&gt;</code> for each field and a <code>Vec&lt;_&gt;</code> for each
record). Since no allocation is performed, this “iterator” doesn’t actually
implement the <code>Iterator</code> trait (since it cannot be done safely).</p>
<p>This is the lowest level interface and should only be used when you need
the performance.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="string">&quot;
sticker,mortals,7
bribed,personae,7
wobbling,poncing,4
interposed,emmett,9
chocolate,refile,7&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rdr</span> <span class="op">=</span> <span class="ident">csv::Reader::from_string</span>(<span class="ident">data</span>);
<span class="kw">while</span> <span class="op">!</span><span class="ident">rdr</span>.<span class="ident">done</span>() {
    <span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">r</span>) <span class="op">=</span> <span class="ident">rdr</span>.<span class="ident">next_bytes</span>().<span class="ident">into_iter_result</span>() {
        <span class="macro">print!</span>(<span class="string">&quot;{:?} &quot;</span>, <span class="ident">r</span>.<span class="ident">unwrap</span>());
    }
    <span class="macro">println!</span>(<span class="string">&quot;&quot;</span>);
}</code></pre></div>
<p>There is more explanation for how this iterator interface works on the
<code>Reader</code> type.</p>
<h2 id="indexing" class="section-header"><a href="#indexing">Indexing</a></h2>
<p>This crate has experimental support for CSV record indexing. It’s very
simplistic, but once the index is created, you can seek a <code>csv::Reader</code>
to any record instantly. See the
<a href="/rustdoc/csv/index/index.html"><code>csv::index</code></a>
sub-module for more details and examples.</p>
<h2 id="compliance-with-rfc-4180" class="section-header"><a href="#compliance-with-rfc-4180">Compliance with RFC 4180</a></h2>
<p><a href="http://tools.ietf.org/html/rfc4180">RFC 4180</a> seems to the closest thing
to an official specification for CSV. Currently, the parser in this crate
will read a strict superset of RFC 4180 while the writer will always write
CSV data that conforms to RFC 4180 (unless configured to do otherwise).
This approach was taken because CSV data is commonly malformed and there is
nothing worse than trying to read busted CSV data with a library that says
it can’t do it.</p>
<p>With that said, a “strict” mode may be added that will only read CSV data
that conforms to RFC 4180.</p>
<p>Here are a few notes on compatibility with RFC 4180:</p>
<ul>
<li>Both CRLF and LF line endings are supported. This is seamless in the
parser. By default, the encoder uses LF line endings but can be
instructed to use CRLF with the <code>crlf</code> method.</li>
<li>The first record is read as a “header” by default, but this can be
disabled by calling <code>has_headers(false)</code> before reading any records.
(N.B. The encoder has no explicit support for headers. Simply encode a
vector of strings instead.)</li>
<li>By default, the delimiter is a comma, but it can be changed to any
<strong>ASCII</strong> byte character with the <code>delimiter</code> method (for either
writing or reading).</li>
<li>By default, both the writer and reader will enforce the invariant
that all records are the same length. (This is what RFC 4180 demands.)
If a record with a different length is found, an error is returned.
This behavior may be turned off by calling <code>flexible</code> with <code>true</code>.</li>
<li>Empty lines (that do not include other whitespace) are ignored
by the parser.</li>
<li>This crates parses CSV data at the <em>byte</em> level, which means all
delimiter and quote characters must be ASCII. While unfortunate, this
means that CSV data that is not UTF-8 encoded can be parsed. In
general, the writer and reader API biases toward using Unicode strings
while providing an outlet to use byte strings.</li>
</ul>
</div></details><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="mod" href="index/index.html" title="csv::index mod">index</a></div><div class="item-right docblock-short"><p>This sub-module provides experimental CSV record indexing.</p>
</div></div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="struct" href="struct.ByteRecords.html" title="csv::ByteRecords struct">ByteRecords</a></div><div class="item-right docblock-short"><p>An iterator of <code>ByteString</code> records.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Decoded.html" title="csv::Decoded struct">Decoded</a></div><div class="item-right docblock-short"><p>A record to be decoded.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.DecodedRecords.html" title="csv::DecodedRecords struct">DecodedRecords</a></div><div class="item-right docblock-short"><p>An iterator of decoded records.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Encoded.html" title="csv::Encoded struct">Encoded</a></div><div class="item-right docblock-short"><p>A record to be encoded.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.LocatableError.html" title="csv::LocatableError struct">LocatableError</a></div><div class="item-right docblock-short"><p>An error tagged with a location at which it occurred.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Reader.html" title="csv::Reader struct">Reader</a></div><div class="item-right docblock-short"><p>A CSV reader.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.StringRecords.html" title="csv::StringRecords struct">StringRecords</a></div><div class="item-right docblock-short"><p>An iterator of <code>String</code> records.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Writer.html" title="csv::Writer struct">Writer</a></div><div class="item-right docblock-short"><p>A CSV writer.</p>
</div></div><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="enum" href="enum.Error.html" title="csv::Error enum">Error</a></div><div class="item-right docblock-short"><p>An error produced by an operation on CSV data.</p>
</div><div class="item-left module-item"><a class="enum" href="enum.NextField.html" title="csv::NextField enum">NextField</a></div><div class="item-right docblock-short"><p>NextField is the result of parsing a single CSV field.</p>
</div><div class="item-left module-item"><a class="enum" href="enum.ParseError.html" title="csv::ParseError enum">ParseError</a></div><div class="item-right docblock-short"><p>A description of a CSV parse error.</p>
</div><div class="item-left module-item"><a class="enum" href="enum.QuoteStyle.html" title="csv::QuoteStyle enum">QuoteStyle</a></div><div class="item-right docblock-short"><p>The quoting style to use when writing CSV data.</p>
</div><div class="item-left module-item"><a class="enum" href="enum.RecordTerminator.html" title="csv::RecordTerminator enum">RecordTerminator</a></div><div class="item-right docblock-short"><p>A record terminator.</p>
</div></div><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="trait" href="trait.BorrowBytes.html" title="csv::BorrowBytes trait">BorrowBytes</a></div><div class="item-right docblock-short"><p>A trait that permits borrowing byte vectors.</p>
</div></div><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="type" href="type.ByteString.html" title="csv::ByteString type">ByteString</a></div><div class="item-right docblock-short"><p>A convenience type for referring to a plain byte string.</p>
</div><div class="item-left module-item"><a class="type" href="type.Result.html" title="csv::Result type">Result</a></div><div class="item-right docblock-short"><p>A convenience type for representing the result of most CSV reader/writer
operations.</p>
</div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="csv" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script>
</body></html>