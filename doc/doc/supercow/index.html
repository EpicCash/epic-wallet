<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`Supercow` is `Cow` on steroids."><meta name="keywords" content="rust, rustlang, rust-lang, supercow"><title>supercow - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../supercow/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate supercow</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.1.0</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all supercow's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></div><div id="sidebar-vars" data-name="supercow" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">supercow</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/supercow/lib.rs.html#9-2526" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>Supercow</code> is <code>Cow</code> on steroids.</p>
<p><code>Supercow</code> provides a mechanism for making APIs that accept or return very
general references while maintaining very low overhead for usages not
involving heavy-weight references (e.g, <code>Arc</code>). Though nominally similar to
<code>Cow</code> in structure (and being named after it), <code>Supercow</code> does not require
the containee to be <code>Clone</code> or <code>ToOwned</code> unless operations inherently
depending on either are invoked.</p>
<p><code>Supercow</code> allows you to</p>
<ul>
<li>
<p>Return values with ownership semantics decided at run-time;</p>
</li>
<li>
<p>Write APIs that allow client code to manage its resources however it
wants;</p>
</li>
<li>
<p>Perform efficient copy-on-write and data sharing;</p>
</li>
<li>
<p>Avoid cloning until absolutely necessary, even if the point at which it
becomes necessary is determined dynamically.</p>
</li>
</ul>
<h1 id="quick-start" class="section-header"><a href="#quick-start">Quick Start</a></h1><h2 id="simple-types" class="section-header"><a href="#simple-types">Simple Types</a></h2>
<p>In many cases, you can think of a <code>Supercow</code> as having only one lifetime
parameter and one type parameter, corresponding to the lifetime and type of
an immutable reference, i.e., <code>Supercow&lt;'a, Type&gt;</code> ⇒ <code>&amp;'a Type</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">supercow</span>;

<span class="kw">use</span> <span class="ident">std::sync::Arc</span>;
<span class="kw">use</span> <span class="ident">supercow::Supercow</span>;

<span class="comment">// This takes a `Supercow`, so it can accept owned, borrowed, or shared</span>
<span class="comment">// values with the same API. The calls to it are annotated below.</span>
<span class="comment">//</span>
<span class="comment">// Normally a function like this would elide the lifetime and/or use an</span>
<span class="comment">// `Into` conversion, but here it is written out for clarity.</span>
<span class="kw">fn</span> <span class="ident">assert_is_forty_two</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="ident">s</span>: <span class="ident">Supercow</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">u32</span><span class="op">&gt;</span>) {
  <span class="comment">// `Supercow` can be dereferenced just like a normal reference.</span>
  <span class="macro">assert_eq!</span>(<span class="number">42</span>, <span class="kw-2">*</span><span class="ident">s</span>);
}

<span class="comment">// Declare some data we want to reference.</span>
<span class="kw">let</span> <span class="ident">forty_two</span> <span class="op">=</span> <span class="number">42u32</span>;
<span class="comment">// Make a Supercow referencing the above.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Supercow::borrowed</span>(<span class="kw-2">&amp;</span><span class="ident">forty_two</span>);
<span class="comment">// It dereferences to the value of `forty_two`.</span>
<span class="ident">assert_is_forty_two</span>(<span class="ident">a</span>.<span class="ident">clone</span>());             <span class="comment">// borrowed</span>
<span class="comment">// And we can see that it actually still *points* to forty_two as well.</span>
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">forty_two</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u32</span>, <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">a</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u32</span>);

<span class="comment">// Clone `a` so that `b` also points to `forty_two`.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">a</span>.<span class="ident">clone</span>();
<span class="ident">assert_is_forty_two</span>(<span class="ident">b</span>.<span class="ident">clone</span>());             <span class="comment">// borrowed</span>
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">forty_two</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u32</span>, <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">b</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u32</span>);

<span class="comment">// `to_mut()` can be used to mutate `a` and `b` independently, taking</span>
<span class="comment">// ownership as needed.</span>
<span class="kw-2">*</span><span class="ident">a</span>.<span class="ident">to_mut</span>() <span class="op">+</span><span class="op">=</span> <span class="number">2</span>;
<span class="comment">// Our immutable variable hasn&#39;t been changed...</span>
<span class="macro">assert_eq!</span>(<span class="number">42</span>, <span class="ident">forty_two</span>);
<span class="comment">// ...but `a` now stores the new value...</span>
<span class="macro">assert_eq!</span>(<span class="number">44</span>, <span class="kw-2">*</span><span class="ident">a</span>);
<span class="comment">// ...and `b` still points to the unmodified variable.</span>
<span class="macro">assert_eq!</span>(<span class="number">42</span>, <span class="kw-2">*</span><span class="ident">b</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">forty_two</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u32</span>, <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">b</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u32</span>);

<span class="comment">// And now we modify `b` as well, which as before affects nothing else.</span>
<span class="kw-2">*</span><span class="ident">b</span>.<span class="ident">to_mut</span>() <span class="op">=</span> <span class="number">56</span>;
<span class="macro">assert_eq!</span>(<span class="number">44</span>, <span class="kw-2">*</span><span class="ident">a</span>);
<span class="macro">assert_eq!</span>(<span class="number">56</span>, <span class="kw-2">*</span><span class="ident">b</span>);
<span class="macro">assert_eq!</span>(<span class="number">42</span>, <span class="ident">forty_two</span>);

<span class="comment">// We can call `assert_is_forty_two` with an owned value as well.</span>
<span class="ident">assert_is_forty_two</span>(<span class="ident">Supercow::owned</span>(<span class="number">42</span>));   <span class="comment">// owned</span>

<span class="comment">// We can also use `Arc` transparently.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">Supercow::shared</span>(<span class="ident">Arc::new</span>(<span class="number">42</span>));
<span class="ident">assert_is_forty_two</span>(<span class="ident">c</span>.<span class="ident">clone</span>());             <span class="comment">// shared</span>
<span class="kw-2">*</span><span class="ident">c</span>.<span class="ident">to_mut</span>() <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
<span class="macro">assert_eq!</span>(<span class="number">43</span>, <span class="kw-2">*</span><span class="ident">c</span>);</code></pre></div>
<h2 id="ownedborrowed-types" class="section-header"><a href="#ownedborrowed-types">Owned/Borrowed Types</a></h2>
<p><code>Supercow</code> can have different owned and borrowed types, for example
<code>String</code> and <code>str</code>. In this case, the two are separate type parameters,
with the owned one written first. (Both need to be listed explicitly since
<code>Supercow</code> does not require the contained value to be <code>ToOwned</code>.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">supercow</span>;

<span class="kw">use</span> <span class="ident">std::sync::Arc</span>;
<span class="kw">use</span> <span class="ident">supercow::Supercow</span>;

<span class="kw">let</span> <span class="ident">hello</span>: <span class="ident">Supercow</span><span class="op">&lt;</span><span class="ident">String</span>, <span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Supercow::borrowed</span>(<span class="string">&quot;hello&quot;</span>);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">hello_world</span> <span class="op">=</span> <span class="ident">hello</span>.<span class="ident">clone</span>();
<span class="ident">hello_world</span>.<span class="ident">to_mut</span>().<span class="ident">push_str</span>(<span class="string">&quot; world&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="ident">hello</span>, <span class="string">&quot;hello&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">hello_world</span>, <span class="string">&quot;hello world&quot;</span>);</code></pre></div>
<h2 id="accepting-supercow-in-an-api" class="section-header"><a href="#accepting-supercow-in-an-api">Accepting <code>Supercow</code> in an API</a></h2>
<p>If you want to make an API taking <code>Supercow</code> values, the recommended
approach is to accept anything that is <code>Into&lt;Supercow&lt;YourType&gt;&gt;</code>, which
allows bare owned types and references to owned values to be accepted as
well.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::Arc</span>;
<span class="kw">use</span> <span class="ident">supercow::Supercow</span>;

<span class="kw">fn</span> <span class="ident">some_api_function</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">T</span> : <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">Supercow</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>,<span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>
  (<span class="ident">t</span>: <span class="ident">T</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Supercow</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>,<span class="ident">u32</span><span class="op">&gt;</span>
{
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">t</span>.<span class="ident">into</span>();
  <span class="kw-2">*</span><span class="ident">x</span>.<span class="ident">to_mut</span>() <span class="kw-2">*</span><span class="op">=</span> <span class="number">2</span>;
  <span class="ident">x</span>
}

<span class="kw">fn</span> <span class="ident">main</span>() {
  <span class="macro">assert_eq!</span>(<span class="number">42</span>, <span class="kw-2">*</span><span class="ident">some_api_function</span>(<span class="number">21</span>));
  <span class="kw">let</span> <span class="ident">twenty_one</span> <span class="op">=</span> <span class="number">21</span>;
  <span class="macro">assert_eq!</span>(<span class="number">42</span>, <span class="kw-2">*</span><span class="ident">some_api_function</span>(<span class="kw-2">&amp;</span><span class="ident">twenty_one</span>));
  <span class="macro">assert_eq!</span>(<span class="number">42</span>, <span class="kw-2">*</span><span class="ident">some_api_function</span>(<span class="ident">Arc::new</span>(<span class="number">21</span>)));
}</code></pre></div>
<h2 id="choosing-the-right-variant" class="section-header"><a href="#choosing-the-right-variant">Choosing the right variant</a></h2>
<p><code>Supercow</code> is extremely flexible as to how it internally stores and manages
data. There are four variants provided by default: <code>Supercow</code>,
<code>NonSyncSupercow</code>, <code>InlineSupercow</code>, and <code>InlineNonSyncSupercow</code>. Here is a
quick reference on the trade-offs:</p>
<table><thead><tr><th>Variant</th><th>Send+Sync?</th><th><code>Rc</code>?</th><th>Size</th><th>Init</th><th>Deref</th></tr></thead><tbody>
<tr><td>(Default)</td><td>Yes</td><td>No</td><td>Small</td><td>Slow</td><td>Very Fast</td></tr>
<tr><td><code>NonSync</code></td><td>No</td><td>Yes</td><td>Small</td><td>Slow</td><td>Very Fast</td></tr>
<tr><td><code>Inline</code></td><td>Yes</td><td>No</td><td>Big</td><td>Fast</td><td>Fast</td></tr>
<tr><td><code>InlineNonSync</code></td><td>No</td><td>Yes</td><td>Big</td><td>Fast</td><td>Fast</td></tr>
</tbody></table>
<p>“Init” above specifically refers to initialisation with an owned value or
shared reference. Supercows constructed with mundane references always
construct extremely quickly.</p>
<p>The only difference between the <code>NonSync</code> variant and the default is that
the default is to require the shared pointer type (e.g., <code>Arc</code>) to be
<code>Send</code> and <code>Sync</code> (which thus prohibits using <code>Rc</code>), whereas <code>NonSync</code> does
not and so allows <code>Rc</code>. Note that a side-effect of the default <code>Send + Sync</code> requirement is that the type of <code>BORROWED</code> also needs to be <code>Send</code>
and <code>Sync</code> when using <code>Arc</code> as the shared reference type; if it is not
<code>Send</code> and <code>Sync</code>, use <code>NonSyncSupercow</code> instead.</p>
<p>By default, <code>Supercow</code> boxes any owned value or shared reference. This
makes the <code>Deref</code> implementation faster since it does not need to account
for internal pointers, but more importantly, means that the <code>Supercow</code> does
not need to reserve space for the owned and shared values, so the default
<code>Supercow</code> is only one pointer wider than a bare reference.</p>
<p>The obvious problem with boxing values is that it makes construction of the
<code>Supercow</code> slower, as one must pay for an allocation. If you want to avoid
the allocation, you can use the <code>Inline</code> variants instead, which store the
values inline inside the <code>Supercow</code>. (Note that if you are looking to
eliminate allocation entirely, you will also need to tinker with the
<code>SHARED</code> type, which by default has its own <code>Box</code> as well.) Note that this
of course makes the <code>Supercow</code> much bigger; be particularly careful if you
create a hierarchy of things containing <code>InlineSupercow</code>s referencing each
other, as each would effectively have space for the entire tree above it
inline.</p>
<p>The default to box values was chosen on the grounds that it is generally
easier to use, less likely to cause confusing problems, and in many cases
the allocation doesn’t affect performance:</p>
<ul>
<li>
<p>In either choice, creating a <code>Supercow</code> with a borrowed reference incurs
no allocation. The boxed option will actually be slightly faster since it
does not need to initialise as much memory and results in better locality
due to being smaller.</p>
</li>
<li>
<p>The value contained usually is reasonably expensive to construct anyway,
or else there would be less incentive to pass it around as a reference when
possible. In these cases, the extra allocation likely is a minor impact on
performance.</p>
</li>
<li>
<p>Overuse of boxed values results in a “uniform slowness” that can be
identified reasonably easily, and results in a linear performance
degradation relative to overuse. Overuse of <code>InlineSupercow</code>s at best
results in linear memory bloat, but if <code>InlineSupercow</code>s reference
structures containing other <code>InlineSupercow</code>s, the result can even be
exponential bloat to the structures. At best, this is a harder problem to
track down; at worst, it can result in entirely non-obvious stack
overflows.</p>
</li>
</ul>
<h1 id="use-cases" class="section-header"><a href="#use-cases">Use Cases</a></h1><h2 id="more-flexible-copy-on-write" class="section-header"><a href="#more-flexible-copy-on-write">More flexible Copy-on-Write</a></h2>
<p><code>std::borrow::Cow</code> only supports two modes of ownership: You either fully
own the value, or only borrow it. <code>Rc</code> and <code>Arc</code> have the <code>make_mut()</code>
method, which allows either total ownership or shared ownership. <code>Supercow</code>
supports all three: owned, shared, and borrowed.</p>
<h2 id="more-flexible-copy-if-needed" class="section-header"><a href="#more-flexible-copy-if-needed">More flexible Copy-if-Needed</a></h2>
<p>A major use of <code>Cow</code> in <code>std</code> is found on functions like
<code>OsStr::to_string_lossy()</code>, which returns a borrowed view into itself if
possible, or an owned string if it needed to change something. If the
caller does not intend to do its own writing, this is more a “copy if
needed” structure, and the fact that it requires the contained value to be
<code>ToOwned</code> limits it to things that can be cloned.</p>
<p><code>Supercow</code> only requires <code>ToOwned</code> if the caller actually intends to invoke
functionality which requires cloning a borrowed value, so it can fit this
use-case even for non-cloneable types.</p>
<h2 id="working-around-awkward-lifetimes" class="section-header"><a href="#working-around-awkward-lifetimes">Working around awkward lifetimes</a></h2>
<p>This is the original case for which <code>Supercow</code> was designed.</p>
<p>Say you have an API with a sort of hierarchical structure of heavyweight
resources, for example handles to a local database and tables within it. A
natural representation may be to make the table handle hold a reference to
the database handle.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct</span> <span class="ident">Database</span>;
<span class="kw">impl</span> <span class="ident">Database</span> {
  <span class="kw">fn</span> <span class="ident">new</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
    <span class="comment">// Computation...</span>
    <span class="ident">Database</span>
  }
  <span class="kw">fn</span> <span class="ident">close</span>(<span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
    <span class="comment">// E.g., it returns an error on failure or something</span>
    <span class="bool-val">true</span>
  }
}
<span class="kw">impl</span> <span class="ident">Drop</span> <span class="kw">for</span> <span class="ident">Database</span> {
  <span class="kw">fn</span> <span class="ident">drop</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) {
    <span class="macro">println!</span>(<span class="string">&quot;Dropping database&quot;</span>);
  }
}
<span class="kw">struct</span> <span class="ident">Table</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Database</span>);
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Table</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
  <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">db</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Database</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
    <span class="comment">// Computation...</span>
    <span class="ident">Table</span>(<span class="ident">db</span>)
  }
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Drop</span> <span class="kw">for</span> <span class="ident">Table</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
  <span class="kw">fn</span> <span class="ident">drop</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) {
    <span class="macro">println!</span>(<span class="string">&quot;Dropping table&quot;</span>);
    <span class="comment">// Notify `self.db` about this</span>
  }
}</code></pre></div>
<p>We can use this quite easily:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">fn</span> <span class="ident">main</span>() {
  <span class="kw">let</span> <span class="ident">db</span> <span class="op">=</span> <span class="ident">Database::new</span>();
  {
    <span class="kw">let</span> <span class="ident">table1</span> <span class="op">=</span> <span class="ident">Table::new</span>(<span class="kw-2">&amp;</span><span class="ident">db</span>);
    <span class="kw">let</span> <span class="ident">table2</span> <span class="op">=</span> <span class="ident">Table::new</span>(<span class="kw-2">&amp;</span><span class="ident">db</span>);
    <span class="ident">do_stuff</span>(<span class="kw-2">&amp;</span><span class="ident">table1</span>);
    <span class="comment">// Etc</span>
  }
  <span class="macro">assert!</span>(<span class="ident">db</span>.<span class="ident">close</span>());
}

<span class="kw">fn</span> <span class="ident">do_stuff</span>(<span class="ident">table</span>: <span class="kw-2">&amp;</span><span class="ident">Table</span>) {
  <span class="comment">// Stuff</span>
}</code></pre></div>
<p>That is, until we want to hold the database and the tables in a struct.</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="kw">struct</span> <span class="ident">Resources</span> {
  <span class="ident">db</span>: <span class="ident">Database</span>,
  <span class="ident">table</span>: <span class="ident">Table</span><span class="op">&lt;</span><span class="lifetime">&#39;uhhh</span><span class="op">&gt;</span>, <span class="comment">// Uh, what is the lifetime here?</span>
}</code></pre></div>
<p>There are several options here:</p>
<ul>
<li>
<p>Change the API to use <code>Arc</code>s or similar. This works, but adds overhead
for clients that don’t need it, and additionally removes from everybody the
ability to statically know whether <code>db.close()</code> can be called.</p>
</li>
<li>
<p>Force clients to resort to unsafety, such as
<a href="http://kimundi.github.io/owning-ref-rs/owning_ref/struct.OwningHandle.html"><code>OwningHandle</code></a>.
This sacrifices no performance and allows the stack-based client usage to
be able to call <code>db.close()</code> easily, but makes things much more difficult
for other clients.</p>
</li>
<li>
<p>Take a <code>Borrow</code> type parameter. This works and is zero-overhead, but
results in a proliferation of generics throughout the API and client code,
and becomes especially problematic when the hierarchy is multiple such
levels deep.</p>
</li>
<li>
<p>Use <code>Supercow</code> to get the best of both worlds.</p>
</li>
</ul>
<p>We can adapt and use the API like so:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::sync::Arc</span>;

<span class="kw">use</span> <span class="ident">supercow::Supercow</span>;

<span class="kw">struct</span> <span class="ident">Database</span>;
<span class="kw">impl</span> <span class="ident">Database</span> {
  <span class="kw">fn</span> <span class="ident">new</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
    <span class="comment">// Computation...</span>
    <span class="ident">Database</span>
  }
  <span class="kw">fn</span> <span class="ident">close</span>(<span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
    <span class="comment">// E.g., it returns an error on failure or something</span>
    <span class="bool-val">true</span>
  }
}
<span class="kw">impl</span> <span class="ident">Drop</span> <span class="kw">for</span> <span class="ident">Database</span> {
  <span class="kw">fn</span> <span class="ident">drop</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) {
    <span class="macro">println!</span>(<span class="string">&quot;Dropping database&quot;</span>);
  }
}
<span class="kw">struct</span> <span class="ident">Table</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="ident">Supercow</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">Database</span><span class="op">&gt;</span>);
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Table</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
  <span class="kw">fn</span> <span class="ident">new</span><span class="op">&lt;</span><span class="ident">T</span> : <span class="ident">Into</span><span class="op">&lt;</span><span class="ident">Supercow</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">Database</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">db</span>: <span class="ident">T</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
    <span class="comment">// Computation...</span>
    <span class="ident">Table</span>(<span class="ident">db</span>.<span class="ident">into</span>())
  }
}
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Drop</span> <span class="kw">for</span> <span class="ident">Table</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
  <span class="kw">fn</span> <span class="ident">drop</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) {
    <span class="macro">println!</span>(<span class="string">&quot;Dropping table&quot;</span>);
    <span class="comment">// Notify `self.db` about this</span>
  }
}

<span class="comment">// The original stack-based code, unmodified</span>

<span class="kw">fn</span> <span class="ident">on_stack</span>() {
  <span class="kw">let</span> <span class="ident">db</span> <span class="op">=</span> <span class="ident">Database::new</span>();
  {
    <span class="kw">let</span> <span class="ident">table1</span> <span class="op">=</span> <span class="ident">Table::new</span>(<span class="kw-2">&amp;</span><span class="ident">db</span>);
    <span class="kw">let</span> <span class="ident">table2</span> <span class="op">=</span> <span class="ident">Table::new</span>(<span class="kw-2">&amp;</span><span class="ident">db</span>);
    <span class="ident">do_stuff</span>(<span class="kw-2">&amp;</span><span class="ident">table1</span>);
    <span class="comment">// Etc</span>
  }
  <span class="macro">assert!</span>(<span class="ident">db</span>.<span class="ident">close</span>());
}

<span class="comment">// If we only wanted one Table and didn&#39;t care about ever getting the</span>
<span class="comment">// Database back, we don&#39;t even need a reference.</span>
<span class="kw">fn</span> <span class="ident">by_value</span>() {
  <span class="kw">let</span> <span class="ident">db</span> <span class="op">=</span> <span class="ident">Database::new</span>();
  <span class="kw">let</span> <span class="ident">table</span> <span class="op">=</span> <span class="ident">Table::new</span>(<span class="ident">db</span>);
  <span class="ident">do_stuff</span>(<span class="kw-2">&amp;</span><span class="ident">table</span>);
}

<span class="comment">// And we can declare our holds-everything struct by using `Arc`s to deal</span>
<span class="comment">// with ownership.</span>
<span class="kw">struct</span> <span class="ident">Resources</span> {
  <span class="ident">db</span>: <span class="ident">Arc</span><span class="op">&lt;</span><span class="ident">Database</span><span class="op">&gt;</span>,
  <span class="ident">table</span>: <span class="ident">Table</span><span class="op">&lt;</span><span class="lifetime">&#39;static</span><span class="op">&gt;</span>,
}
<span class="kw">impl</span> <span class="ident">Resources</span> {
  <span class="kw">fn</span> <span class="ident">new</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
    <span class="kw">let</span> <span class="ident">db</span> <span class="op">=</span> <span class="ident">Arc::new</span>(<span class="ident">Database::new</span>());
    <span class="kw">let</span> <span class="ident">table</span> <span class="op">=</span> <span class="ident">Table::new</span>(<span class="ident">db</span>.<span class="ident">clone</span>());
    <span class="ident">Resources</span> { <span class="ident">db</span>: <span class="ident">db</span>, <span class="ident">table</span>: <span class="ident">table</span> }
  }

  <span class="kw">fn</span> <span class="ident">close</span>(<span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
    <span class="ident">drop</span>(<span class="self">self</span>.<span class="ident">table</span>);
    <span class="ident">Arc::try_unwrap</span>(<span class="self">self</span>.<span class="ident">db</span>).<span class="ident">ok</span>().<span class="ident">unwrap</span>().<span class="ident">close</span>()
  }
}

<span class="kw">fn</span> <span class="ident">with_struct</span>() {
  <span class="kw">let</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">Resources::new</span>();
  <span class="ident">do_stuff</span>(<span class="kw-2">&amp;</span><span class="ident">res</span>.<span class="ident">table</span>);
  <span class="macro">assert!</span>(<span class="ident">res</span>.<span class="ident">close</span>());
}

<span class="kw">fn</span> <span class="ident">do_stuff</span>(<span class="ident">table</span>: <span class="kw-2">&amp;</span><span class="ident">Table</span>) {
  <span class="comment">// Stuff</span>
}
</code></pre></div>
<h1 id="conversions" class="section-header"><a href="#conversions">Conversions</a></h1>
<p>To facilitate client API designs, <code>Supercow</code> converts (via <code>From</code>/<code>Into</code>)
from a number of things. Unfortunately, due to trait coherence rules, this
does not yet apply in all cases where one might hope. The currently
available conversions are:</p>
<ul>
<li>
<p>The <code>OWNED</code> type into an owned <code>Supercow</code>. This applies without
restriction.</p>
</li>
<li>
<p>A reference to the <code>OWNED</code> type. References to a different <code>BORROWED</code>
type are currently not convertible; <code>Supercow::borrowed()</code> will be needed
to construct the <code>Supercow</code> explicitly.</p>
</li>
<li>
<p><code>Rc&lt;OWNED&gt;</code> and <code>Arc&lt;OWNED&gt;</code> for <code>Supercow</code>s where <code>OWNED</code> and <code>BORROWED</code>
are the exact same type, and where the <code>Rc</code> or <code>Arc</code> can be converted into
<code>SHARED</code> via <code>supercow::ext::SharedFrom</code>. If <code>OWNED</code> and <code>BORROWED</code> are
different types, <code>Supercow::shared()</code> will be needed to construct the
<code>Supercow</code> explicitly.</p>
</li>
</ul>
<h1 id="advanced" class="section-header"><a href="#advanced">Advanced</a></h1><h2 id="variance" class="section-header"><a href="#variance">Variance</a></h2>
<p><code>Supercow</code> is covariant on its lifetime and all its type parameters, except
for <code>SHARED</code> which is invariant. The default <code>SHARED</code> type for both
<code>Supercow</code> and <code>NonSyncSupercow</code> uses the <code>'static</code> lifetime, so simple
<code>Supercow</code>s are in general covariant.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::rc::Rc</span>;

<span class="kw">use</span> <span class="ident">supercow::Supercow</span>;

<span class="kw">fn</span> <span class="ident">assert_covariance</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;b</span>: <span class="lifetime">&#39;a</span><span class="op">&gt;</span>(
  <span class="ident">imm</span>: <span class="ident">Supercow</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span>, <span class="ident">u32</span><span class="op">&gt;</span>,
  <span class="ident">bor</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b</span> <span class="ident">Supercow</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span>, <span class="ident">u32</span><span class="op">&gt;</span>)
{
  <span class="kw">let</span> <span class="ident">_imm_a</span>: <span class="ident">Supercow</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">imm</span>;
  <span class="kw">let</span> <span class="ident">_bor_aa</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Supercow</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bor</span>;
  <span class="kw">let</span> <span class="ident">_bor_ab</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Supercow</span><span class="op">&lt;</span><span class="lifetime">&#39;b</span>, <span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bor</span>;
  <span class="comment">// Invalid, since the external `&amp;&#39;b` reference is declared to live longer</span>
  <span class="comment">// than the internal `&amp;&#39;a` reference.</span>
  <span class="comment">// let _bor_ba: &amp;&#39;b Supercow&lt;&#39;a, u32&gt; = bor;</span>
}
</code></pre></div>
<h2 id="sync-and-send" class="section-header"><a href="#sync-and-send"><code>Sync</code> and <code>Send</code></a></h2>
<p>A <code>Supercow</code> is <code>Sync</code> and <code>Send</code> iff the types it contains, including the
shared reference type, are.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">supercow::Supercow</span>;

<span class="kw">fn</span> <span class="ident">assert_sync_and_send</span><span class="op">&lt;</span><span class="ident">T</span> : <span class="ident">Sync</span> <span class="op">+</span> <span class="ident">Send</span><span class="op">&gt;</span>(<span class="kw">_</span>: <span class="ident">T</span>) { }
<span class="kw">fn</span> <span class="ident">main</span>() {
  <span class="kw">let</span> <span class="ident">s</span>: <span class="ident">Supercow</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Supercow::owned</span>(<span class="number">42</span>);
  <span class="ident">assert_sync_and_send</span>(<span class="ident">s</span>);
}</code></pre></div>
<h2 id="shared-reference-type" class="section-header"><a href="#shared-reference-type">Shared Reference Type</a></h2>
<p>The third type parameter type to <code>Supercow</code> specifies the shared reference
type.</p>
<p>The default is <code>Box&lt;DefaultFeatures&lt;'static&gt;&gt;</code>, which is a boxed trait
object describing the features a shared reference type must have while
allowing any such reference to be used without needing a generic type
argument.</p>
<p>An alternate feature set can be found in <code>NonSyncFeatures</code>, which is also
usable through the <code>NonSyncSupercow</code> typedef (which also makes it
<code>'static</code>). You can create custom feature traits in this style with
<code>supercow_features!</code>.</p>
<p>It is perfectly legal to use a non-<code>'static</code> shared reference type. In
fact, the original design for <code>Supercow&lt;'a&gt;</code> used <code>DefaultFeatures&lt;'a&gt;</code>.
However, a non-<code>'static</code> lifetime makes the system harder to use, and if
entangled with <code>'a</code> on <code>Supercow</code>, makes the structure lifetime-invariant,
which makes it much harder to treat as a reference.</p>
<p>Boxing the shared reference and putting it behind a trait object both add
overhead, of course. If you wish, you can use a real reference type in the
third parameter as long as you are OK with losing the flexibility the
boxing would provide. For example,</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::rc::Rc</span>;

<span class="kw">use</span> <span class="ident">supercow::Supercow</span>;

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">Supercow</span><span class="op">&lt;</span><span class="ident">u32</span>, <span class="ident">u32</span>, <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Supercow::shared</span>(<span class="ident">Rc::new</span>(<span class="number">42u32</span>));
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">x</span>);</code></pre></div>
<p>Note that you may need to provide an identity <code>supercow::ext::SharedFrom</code>
implementation if you have a custom reference type.</p>
<h2 id="storage-type" class="section-header"><a href="#storage-type">Storage Type</a></h2>
<p>When in owned or shared mode, a <code>Supercow</code> needs someplace to store the
<code>OWNED</code> or <code>SHARED</code> value itself. This can be customised with the fourth
type parameter (<code>STORAGE</code>), and the <code>OwnedStorage</code> trait. Two strategies
are provided by this crate:</p>
<ul>
<li>
<p><code>BoxedStorage</code> puts everything behind <code>Box</code>es. This has the advantage
that the <code>Supercow</code> structure is only one pointer wider than a basic
reference, and results in a faster <code>Deref</code>. The obvious drawback is that
you pay for allocations on construction. This is the default with
<code>Supercow</code> and <code>NonSyncSupercow</code>.</p>
</li>
<li>
<p><code>InlineStorage</code> uses an <code>enum</code> to store the values inline in the
<code>Supercow</code>, thus incurring no allocation, but making the <code>Supercow</code> itself
bigger. This is easily available via the <code>InlineSupercow</code> and
<code>InlineNonSyncSupercow</code> types.</p>
</li>
</ul>
<p>If you find some need, you can define custom storage types, though note
that the trait is quite unsafe and somewhat subtle.</p>
<h2 id="ptr-type" class="section-header"><a href="#ptr-type"><code>PTR</code> type</a></h2>
<p>The <code>PTR</code> type is used to consolidate the implementations of <code>Supercow</code> and
<code>Phantomcow</code>; there is likely little, if any, use for ever using anything
other than <code>*const BORROWED</code> or <code>()</code> here.</p>
<h1 id="performance-considerations" class="section-header"><a href="#performance-considerations">Performance Considerations</a></h1><h2 id="construction-cost" class="section-header"><a href="#construction-cost">Construction Cost</a></h2>
<p>Since it inherently moves certain decisions about ownership from
compile-time to run-time, <code>Supercow</code> is obviously not as fast as using an
owned value directly or a reference directly.</p>
<p>Constructing any kind of <code>Supercow</code> with a normal reference is very fast,
only requiring a bit of internal memory initialisation besides setting the
reference itself.</p>
<p>The default <code>Supercow</code> type boxes the owned type and double-boxes the shared
type. This obviously dominates construction cost in those cases.</p>
<p><code>InlineSupercow</code> eliminates one box layer. This means that constructing an
owned instance is simply a move of the owned structure plus the common
reference initialisation. Shared values still by default require one boxing
level as well as virtual dispatch on certain operations; as described
above, this property too can be dealt with by using a custom <code>SHARED</code> type.</p>
<h2 id="destruction-cost" class="section-header"><a href="#destruction-cost">Destruction Cost</a></h2>
<p>Destroying a <code>Supercow</code> is roughly the same proportional cost of creating
it.</p>
<h2 id="deref-cost" class="section-header"><a href="#deref-cost"><code>Deref</code> Cost</a></h2>
<p>For the default <code>Supercow</code> type, the <code>Deref</code> is exactly equivalent to
dereferencing an <code>&amp;&amp;BORROWED</code>.</p>
<p>For <code>InlineSupercow</code>, the implementation is a bit slower, comparable to
<code>std::borrow::Cow</code> but with fewer memory accesses..</p>
<p>In all cases, the <code>Deref</code> implementation is not dependent on the ownership
mode of the <code>Supercow</code>, and so is not affected by the shared reference
type, most importantly, making no virtual function calls even under the
default boxed shared reference type. However, the way it works could
prevent LLVM optimisations from applying in particular circumstances.</p>
<p>For those wanting specifics, the function</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="comment">// Substitute Cow with InlineSupercow for the other case.</span>
<span class="comment">// This takes references so that the destructor code is not intermingled.</span>
<span class="kw">fn</span> <span class="ident">add_two</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span><span class="ident">Cow</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>, <span class="ident">b</span>: <span class="kw-2">&amp;</span><span class="ident">Cow</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">u32</span> {
  <span class="kw-2">*</span><span class="kw-2">*</span><span class="ident">a</span> <span class="op">+</span> <span class="kw-2">*</span><span class="kw-2">*</span><span class="ident">b</span>
}</code></pre></div>
<p>results in the following on AMD64 with Rust 1.13.0:</p>
<div class="example-wrap"><pre class="language-text"><code> Cow                                Supercow
 cmp    DWORD PTR [rdi],0x1         mov    rcx,QWORD PTR [rdi]
 lea    rcx,[rdi+0x4]               xor    eax,eax
 cmovne rcx,QWORD PTR [rdi+0x8]     cmp    rcx,0x800
 cmp    DWORD PTR [rsi],0x1         cmovae rdi,rax
 lea    rax,[rsi+0x4]               mov    rdx,QWORD PTR [rsi]
 cmovne rax,QWORD PTR [rsi+0x8]     cmp    rdx,0x800
 mov    eax,DWORD PTR [rax]         cmovb  rax,rsi
 add    eax,DWORD PTR [rcx]         mov    eax,DWORD PTR [rax+rdx]
 ret                                add    eax,DWORD PTR [rdi+rcx]
                                    ret</code></pre></div>
<p>The same code on ARM v7l and Rust 1.12.1:</p>
<div class="example-wrap"><pre class="language-text"><code> Cow                                Supercow
 push       {fp, lr}                ldr     r2, [r0]
 mov        r2, r0                  ldr     r3, [r1]
 ldr        r3, [r2, #4]!           cmp     r2, #2048
 ldr        ip, [r0]                addcc   r2, r2, r0
 mov        r0, r1                  cmp     r3, #2048
 ldr        lr, [r0, #4]!           addcc   r3, r3, r1
 ldr        r1, [r1]                ldr     r0, [r2]
 cmp        ip, #1                  ldr     r1, [r3]
 moveq      r3, r2                  add     r0, r1, r0
 cmp        r1, #1                  bx      lr
 ldr        r2, [r3]
 moveq      lr, r0
 ldr        r0, [lr]
 add        r0, r0, r2
 pop        {fp, pc}</code></pre></div>
<p>If the default <code>Supercow</code> is used above instead of <code>InlineSupercow</code>, the
function actually compiles to the same thing as one taking two <code>&amp;u32</code>
arguments. (This is partially due to optimisations eliminating one level of
indirection; if the optimiser did not do as much, it would be equivalent to
taking two <code>&amp;&amp;u32</code> arguments.)</p>
<h2 id="to_mut-cost" class="section-header"><a href="#to_mut-cost"><code>to_mut</code> Cost</a></h2>
<p>Obtaining a <code>Ref</code> is substantially more expensive than <code>Deref</code>, as it must
inspect the ownership mode of the <code>Supercow</code> and possibly move it into the
owned mode. This will include a virtual call to the boxed shared reference
if in shared mode when using the default <code>Supercow</code> shared reference type.</p>
<p>There is also cost in releasing the mutable reference, though
insubstantial in comparison.</p>
<h2 id="memory-usage" class="section-header"><a href="#memory-usage">Memory Usage</a></h2>
<p>The default <code>Supercow</code> is only one pointer wider than a mundane reference
on Rust 1.13.0 and later. Earlier Rust versions have an extra word due to
the drop flag.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::mem::size_of</span>;

<span class="kw">use</span> <span class="ident">supercow::Supercow</span>;

<span class="comment">// Determine the size of the drop flag including alignment padding.</span>
<span class="comment">// On Rust 0.13.0+, `dflag` will be zero.</span>
<span class="kw">struct</span> <span class="ident">DropFlag</span>(<span class="kw-2">*</span><span class="kw">const</span> ());
<span class="kw">impl</span> <span class="ident">Drop</span> <span class="kw">for</span> <span class="ident">DropFlag</span> { <span class="kw">fn</span> <span class="ident">drop</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>) { } }
<span class="kw">let</span> <span class="ident">dflag</span> <span class="op">=</span> <span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">DropFlag</span><span class="op">&gt;</span>() <span class="op">-</span> <span class="ident">size_of</span>::<span class="op">&lt;</span><span class="kw-2">*</span><span class="kw">const</span> ()<span class="op">&gt;</span>();

<span class="macro">assert_eq!</span>(<span class="ident">size_of</span>::<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">u32</span><span class="op">&gt;</span>() <span class="op">+</span> <span class="ident">size_of</span>::<span class="op">&lt;</span><span class="kw-2">*</span><span class="kw">const</span> ()<span class="op">&gt;</span>() <span class="op">+</span> <span class="ident">dflag</span>,
           <span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">Supercow</span><span class="op">&lt;</span><span class="lifetime">&#39;static</span>, <span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span>());

<span class="macro">assert_eq!</span>(<span class="ident">size_of</span>::<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span>() <span class="op">+</span> <span class="ident">size_of</span>::<span class="op">&lt;</span><span class="kw-2">*</span><span class="kw">const</span> ()<span class="op">&gt;</span>() <span class="op">+</span> <span class="ident">dflag</span>,
           <span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">Supercow</span><span class="op">&lt;</span><span class="lifetime">&#39;static</span>, <span class="ident">String</span>, <span class="ident">str</span><span class="op">&gt;</span><span class="op">&gt;</span>());</code></pre></div>
<p>Of course, you also pay for heap space in this case when using owned or
shared <code>Supercow</code>s.</p>
<p><code>InlineSupercow</code> can be quite large in comparison to a normal reference.
You need to be particularly careful that structures you reference don’t
themselves contain <code>InlineSupercow</code>s or you can end up with
quadratically-sized or even exponentially-sized structures.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::mem</span>;

<span class="kw">use</span> <span class="ident">supercow::InlineSupercow</span>;

<span class="comment">// Define our structures</span>
<span class="kw">struct</span> <span class="ident">Big</span>([<span class="ident">u8</span>;<span class="number">1024</span>]);
<span class="kw">struct</span> <span class="ident">A</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="ident">InlineSupercow</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">Big</span><span class="op">&gt;</span>);
<span class="kw">struct</span> <span class="ident">B</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="ident">InlineSupercow</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">A</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span>);
<span class="kw">struct</span> <span class="ident">C</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>(<span class="ident">InlineSupercow</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">B</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span>);

<span class="comment">// Now say an API consumer, etc, decides to use references</span>
<span class="kw">let</span> <span class="ident">big</span> <span class="op">=</span> <span class="ident">Big</span>([<span class="number">0u8</span>;<span class="number">1024</span>]);
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">A</span>((<span class="kw-2">&amp;</span><span class="ident">big</span>).<span class="ident">into</span>());
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">B</span>((<span class="kw-2">&amp;</span><span class="ident">a</span>).<span class="ident">into</span>());
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">C</span>((<span class="kw-2">&amp;</span><span class="ident">b</span>).<span class="ident">into</span>());

<span class="comment">// Well, we&#39;ve now allocated space for four `Big`s on the stack, despite</span>
<span class="comment">// only really needing one.</span>
<span class="macro">assert!</span>(<span class="ident">mem::size_of_val</span>(<span class="kw-2">&amp;</span><span class="ident">big</span>) <span class="op">+</span> <span class="ident">mem::size_of_val</span>(<span class="kw-2">&amp;</span><span class="ident">a</span>) <span class="op">+</span>
        <span class="ident">mem::size_of_val</span>(<span class="kw-2">&amp;</span><span class="ident">b</span>) <span class="op">+</span> <span class="ident">mem::size_of_val</span>(<span class="kw-2">&amp;</span><span class="ident">c</span>) <span class="op">&gt;</span>
        <span class="number">4</span> <span class="op">*</span> <span class="ident">mem::size_of</span>::<span class="op">&lt;</span><span class="ident">Big</span><span class="op">&gt;</span>());</code></pre></div>
<h1 id="other-notes" class="section-header"><a href="#other-notes">Other Notes</a></h1>
<p>Using <code>Supercow</code> will not give your application <code>apt-get</code>-style Super Cow
Powers.</p>
</div></details><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="mod" href="ext/index.html" title="supercow::ext mod">ext</a></div><div class="item-right docblock-short"><p>Miscellaneous things used to integrate other code with Supercow, but which
are not of interest to most client developers.</p>
</div></div><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="macro" href="macro.supercow_features.html" title="supercow::supercow_features macro">supercow_features</a></div><div class="item-right docblock-short"><p>Defines a “feature set” for a custom <code>Supercow</code> type.</p>
</div></div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="struct" href="struct.Ref.html" title="supercow::Ref struct">Ref</a></div><div class="item-right docblock-short"><p>Provides mutable access to an owned value within a <code>Supercow</code>.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Supercow.html" title="supercow::Supercow struct">Supercow</a></div><div class="item-right docblock-short"><p>The actual generic reference type.</p>
</div></div><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="trait" href="trait.DefaultFeatures.html" title="supercow::DefaultFeatures trait">DefaultFeatures</a></div><div class="item-right docblock-short"><p>The default shared reference type for <code>Supercow</code>.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.NonSyncFeatures.html" title="supercow::NonSyncFeatures trait">NonSyncFeatures</a></div><div class="item-right docblock-short"><p>The shared reference type for <code>NonSyncSupercow</code>.</p>
</div></div><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="type" href="type.InlineNonSyncPhantomcow.html" title="supercow::InlineNonSyncPhantomcow type">InlineNonSyncPhantomcow</a></div><div class="item-right docblock-short"><p>The <code>Phantomcow</code> variant corresponding to <code>InlineNonSyncSupercow</code>.</p>
</div><div class="item-left module-item"><a class="type" href="type.InlineNonSyncSupercow.html" title="supercow::InlineNonSyncSupercow type">InlineNonSyncSupercow</a></div><div class="item-right docblock-short"><p><code>NonSyncSupercow</code> with the <code>STORAGE</code> changed to <code>InlineStorage</code>.</p>
</div><div class="item-left module-item"><a class="type" href="type.InlinePhantomcow.html" title="supercow::InlinePhantomcow type">InlinePhantomcow</a></div><div class="item-right docblock-short"><p>The <code>Phantomcow</code> variant corresponding to <code>InlineStorage</code>.</p>
</div><div class="item-left module-item"><a class="type" href="type.InlineSupercow.html" title="supercow::InlineSupercow type">InlineSupercow</a></div><div class="item-right docblock-short"><p><code>Supercow</code> with the default <code>STORAGE</code> changed to <code>InlineStorage</code>.</p>
</div><div class="item-left module-item"><a class="type" href="type.NonSyncPhantomcow.html" title="supercow::NonSyncPhantomcow type">NonSyncPhantomcow</a></div><div class="item-right docblock-short"><p>The <code>Phantomcow</code> variant corresponding to <code>NonSyncSupercow</code>.</p>
</div><div class="item-left module-item"><a class="type" href="type.NonSyncSupercow.html" title="supercow::NonSyncSupercow type">NonSyncSupercow</a></div><div class="item-right docblock-short"><p><code>Supercow</code> with the default <code>SHARED</code> changed to <code>NonSyncFeatures</code>, enabling
the use of <code>Rc</code> as a shared reference type as well as making it possible to
use non-<code>Send</code> or non-<code>Sync</code> <code>BORROWED</code> types easily.</p>
</div><div class="item-left module-item"><a class="type" href="type.Phantomcow.html" title="supercow::Phantomcow type">Phantomcow</a></div><div class="item-right docblock-short"><p><code>Phantomcow&lt;'a, Type&gt;</code> is to <code>Supercow&lt;'a, Type&gt;</code> as
<code>PhantomData&lt;&amp;'a Type&gt;</code> is to <code>&amp;'a Type</code>.</p>
</div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="supercow" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script>
</body></html>