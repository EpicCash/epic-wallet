initSidebarItems({"struct":[["AcceptConn","Returns a value indicating whether or not this socket has been marked to accept connections with `listen(2)`."],["Broadcast","Set or get the broadcast flag."],["IpAddMembership","Join a multicast group"],["IpDropMembership","Leave a multicast group."],["IpMulticastLoop","Set or read a boolean integer argument that determines whether sent multicast packets should be looped back to the local sockets."],["IpMulticastTtl","Set or read the time-to-live value of outgoing multicast packets for this socket."],["Ipv4PacketInfo","Pass an `IP_PKTINFO` ancillary message that contains a pktinfo structure that supplies some information about the incoming packet."],["Ipv4RecvDstAddr","The `recvmsg(2)` call will return the destination IP address for a UDP datagram."],["Ipv4RecvIf","The `recvmsg(2)` call returns a `struct sockaddr_dl` corresponding to the interface on which the packet was received."],["Ipv6AddMembership","Join an IPv6 multicast group."],["Ipv6DropMembership","Leave an IPv6 multicast group."],["Ipv6RecvPacketInfo","Set delivery of the `IPV6_PKTINFO` control message on incoming datagrams."],["Ipv6V6Only","The socket is restricted to sending and receiving IPv6 packets only."],["KeepAlive","Enable sending of keep-alive messages on connection-oriented sockets."],["Linger","When enabled,  a close(2) or shutdown(2) will not return until all queued messages for the socket have been successfully sent or the linger timeout has been reached."],["LocalPeerCred","Get the credentials of the peer process of a connected unix domain socket."],["OobInline","If this option is enabled, out-of-band data is directly placed into the receive data stream."],["RcvBuf","Sets or gets the maximum socket receive buffer in bytes."],["ReceiveTimeout","Specify the receiving timeout until reporting an error."],["ReceiveTimestamp","Enable or disable the receiving of the `SO_TIMESTAMP` control message."],["ReuseAddr","Enables local address reuse"],["ReusePort","Permits multiple AF_INET or AF_INET6 sockets to be bound to an identical socket address."],["SendTimeout","Specify the sending timeout until reporting an error."],["SndBuf","Sets or gets the maximum socket send buffer in bytes."],["SockType","Gets the socket type as an integer."],["SocketError","Get and clear the pending socket error."],["TcpKeepAlive","Specify the amount of time, in seconds, that the connection must be idle before keepalive probes (if enabled) are sent."],["TcpKeepCount","The maximum number of keepalive probes TCP should send before dropping the connection."],["TcpKeepInterval","The time (in seconds) between individual keepalive probes."],["TcpMaxSeg","The maximum segment size for outgoing TCP packets."],["TcpNoDelay","Under most circumstances, TCP sends data when it is presented; when outstanding data has not yet been acknowledged, it gathers small amounts of output to be sent in a single packet once an acknowledgement is received.  For a small number of clients, such as window systems that send a stream of mouse events which receive no replies, this packetization may cause significant delays.  The boolean option TCP_NODELAY defeats this algorithm."]]});